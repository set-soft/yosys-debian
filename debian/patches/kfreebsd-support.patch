From: Sebastian Kuzminsky <seb@highlab.com>
Date: Sat, 14 May 2016 15:44:13 +0200
Subject: Change yosys to look for the #define constant "__unix__" instead of
 "__linux__",
 to select code appropriate for Unix-like systems. This has been tested with
 Clang 3.5 and GCC 4.6, 4.8, and 4.9 on Linux,
 and Clang 3.5 and GCC 4.9 on kFreeBSD.

---
 kernel/driver.cc       | 6 +++---
 kernel/log.cc          | 6 +++---
 kernel/log.h           | 2 +-
 kernel/yosys.cc        | 4 ++--
 libs/minisat/System.cc | 4 ++--
 libs/minisat/System.h  | 2 +-
 passes/cmds/cover.cc   | 2 +-
 7 files changed, 13 insertions(+), 13 deletions(-)

--- a/kernel/driver.cc
+++ b/kernel/driver.cc
@@ -30,7 +30,7 @@
 #include <limits.h>
 #include <errno.h>
 
-#ifdef __linux__
+#ifdef __unix__
 #  include <sys/types.h>
 #  include <unistd.h>
 #endif
@@ -409,7 +409,7 @@
 #else
 		std::string meminfo;
 		std::string stats_divider = ", ";
-#  ifdef __linux__
+#  ifdef __unix__
 		std::ifstream statm;
 		statm.open(stringf("/proc/%lld/statm", (long long)getpid()));
 		if (statm.is_open()) {
@@ -463,7 +463,7 @@
 		}
 	}
 
-#if defined(YOSYS_ENABLE_COVER) && defined(__linux__)
+#if defined(YOSYS_ENABLE_COVER) && defined(__unix__)
 	if (getenv("YOSYS_COVER_DIR") || getenv("YOSYS_COVER_FILE"))
 	{
 		string filename;
--- a/kernel/log.cc
+++ b/kernel/log.cc
@@ -25,7 +25,7 @@
 #  include <sys/time.h>
 #endif
 
-#ifdef __linux__
+#ifdef __unix__
 #  include <dlfcn.h>
 #endif
 
@@ -280,7 +280,7 @@
 	log_flush();
 }
 
-#if defined(__linux__) && defined(YOSYS_ENABLE_PLUGINS)
+#if defined(__unix__) && defined(YOSYS_ENABLE_PLUGINS)
 void log_backtrace(const char *prefix, int levels)
 {
 	if (levels <= 0) return;
@@ -464,7 +464,7 @@
 // ---------------------------------------------------
 // This is the magic behind the code coverage counters
 // ---------------------------------------------------
-#if defined(YOSYS_ENABLE_COVER) && defined(__linux__)
+#if defined(YOSYS_ENABLE_COVER) && defined(__unix__)
 
 dict<std::string, std::pair<std::string, int>> extra_coverage_data;
 
--- a/kernel/log.h
+++ b/kernel/log.h
@@ -106,7 +106,7 @@
 // This is the magic behind the code coverage counters
 // ---------------------------------------------------
 
-#if defined(YOSYS_ENABLE_COVER) && defined(__linux__)
+#if defined(YOSYS_ENABLE_COVER) && defined(__unix__)
 
 #define cover(_id) do { \
     static CoverData __d __attribute__((section("yosys_cover_list"), aligned(1), used)) = { __FILE__, __FUNCTION__, _id, __LINE__, 0 }; \
--- a/kernel/yosys.cc
+++ b/kernel/yosys.cc
@@ -66,7 +66,7 @@
 
 void memhasher_on()
 {
-#ifdef __linux__
+#ifdef __unix__
 	memhasher_rng += time(NULL) << 16 ^ getpid();
 #endif
 	memhasher_store.resize(0x10000);
@@ -647,7 +647,7 @@
 } TclPass;
 #endif
 
-#if defined(__linux__) || defined(__CYGWIN__)
+#if defined(__unix__) || defined(__CYGWIN__)
 std::string proc_self_dirname()
 {
 	char path[PATH_MAX];
--- a/libs/minisat/System.cc
+++ b/libs/minisat/System.cc
@@ -25,7 +25,7 @@
 
 #include "System.h"
 
-#if defined(__linux__)
+#if defined(__unix__)
 
 #include <stdlib.h>
 
@@ -99,7 +99,7 @@
 
 void Minisat::setX86FPUPrecision()
 {
-#if defined(__linux__) && defined(_FPU_EXTENDED) && defined(_FPU_DOUBLE) && defined(_FPU_GETCW)
+#if defined(__unix__) && defined(_FPU_EXTENDED) && defined(_FPU_DOUBLE) && defined(_FPU_GETCW)
     // Only correct FPU precision on Linux architectures that needs and supports it:
     fpu_control_t oldcw, newcw;
     _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
--- a/libs/minisat/System.h
+++ b/libs/minisat/System.h
@@ -21,7 +21,7 @@
 #ifndef Minisat_System_h
 #define Minisat_System_h
 
-#if defined(__linux__)
+#if defined(__unix__)
 #include <fpu_control.h>
 #endif
 
--- a/passes/cmds/cover.cc
+++ b/passes/cmds/cover.cc
@@ -128,7 +128,7 @@
 			log("\n");
 		}
 
-#if defined(YOSYS_ENABLE_COVER) && defined(__linux__)
+#if defined(YOSYS_ENABLE_COVER) && defined(__unix__)
 		for (auto &it : get_coverage_data()) {
 			if (!patterns.empty()) {
 				for (auto &p : patterns)
